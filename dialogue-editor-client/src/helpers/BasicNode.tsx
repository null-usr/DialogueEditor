import React, { memo, FC, CSSProperties, useState, useEffect } from 'react'
import {
    Handle,
    Position,
    NodeProps,
    Connection,
    Edge,
    XYPosition,
} from 'react-flow-renderer'

import { render } from 'react-dom'
import { StringField } from './FieldComponents/StringField'
import { Container } from './styles'

interface iFieldData {
    [key: string]: string
}

// need to do a check that all the keys are unique
export const VariableNode: React.FC<{
    callback?(arg1: iFieldData[]): void
    data?: iFieldData[]
}> = ({ callback, data }) => {
    const [fields, setFields] = useState<iFieldData[]>(data || [])
    const [count, setCount] = useState(1)

    const addField = () => {
        setFields([...fields, { key: `key ${count}`, value: `value ${count}` }])
        setCount(count + 1)
    }

    useEffect(() => {
        if (callback) callback(fields)
    }, [fields])

    // https://stackoverflow.com/questions/43230622/reactjs-how-to-delete-item-from-list/43230714
    const deleteField = (id: string) => {
        setFields(fields.filter((el) => el.key !== id))
    }

    return (
        <Container>
            <button onClick={addField}>Add Text Field</button>
            {fields.map((field) => (
                <StringField
                    del={deleteField}
                    key={field.key}
                    k={field.key}
                    v={field.value}
                />
            ))}
        </Container>
    )
}

class BasicNode {
    private static last_id: number = 2

    id: string

    fields: iFieldData[]

    // data is generated by the character name and dialogue option
    data: object = {}

    // position is based on the x and y variables
    // this could probably be surfaced as an object instead of this read only thing
    // but who's to say
    position: XYPosition

    updateFields(newFields: iFieldData[]) {
        this.fields = newFields
    }

    // ctor
    constructor(x: number, y: number) {
        this.id = (BasicNode.last_id++).toString()
        this.position = { x, y }
        this._set_data()
        this.fields = []
    }

    private _set_data() {
        this.data = {
            label: (
                <VariableNode
                    data={this.fields}
                    callback={this.updateFields.bind(this)}
                />
            ),
        }
    }

    // here we look into our component and grab all the data we need
    public serialize = (): Object => {
        console.log(this.fields)
        return {}
    }
}

export default BasicNode
// export default memo(ColorSelectorNode);
